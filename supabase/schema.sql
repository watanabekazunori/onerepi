-- ============================================
-- Onerepi - Supabase Database Schema
-- Run this in your Supabase SQL Editor
-- ============================================

-- Enable UUID extension
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- ============ User Profiles ============
-- Extended user profile with preferences
CREATE TABLE IF NOT EXISTS user_profiles (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE UNIQUE,
    name TEXT NOT NULL DEFAULT 'ユーザー',
    cooking_skill TEXT NOT NULL DEFAULT 'beginner' CHECK (cooking_skill IN ('beginner', 'normal', 'expert')),
    cooking_time_preference TEXT NOT NULL DEFAULT '20',
    interests TEXT[] DEFAULT '{}',
    seasonings TEXT[] DEFAULT '{}',
    dislikes TEXT[] DEFAULT '{}',
    household_size INTEGER DEFAULT 1,
    avatar_url TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- ============ Cooking Feedback ============
-- Feedback after cooking each recipe
CREATE TABLE IF NOT EXISTS cooking_feedback (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    recipe_id TEXT NOT NULL,
    rating INTEGER NOT NULL CHECK (rating >= 1 AND rating <= 5),
    taste_rating INTEGER CHECK (taste_rating >= 1 AND taste_rating <= 5),
    difficulty_rating INTEGER CHECK (difficulty_rating >= 1 AND difficulty_rating <= 5),
    would_make_again BOOLEAN DEFAULT false,
    notes TEXT,
    photo_url TEXT,
    cooked_at TIMESTAMP WITH TIME ZONE NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- ============ User Preferences (Learned) ============
-- Preferences learned from explicit input and feedback
CREATE TABLE IF NOT EXISTS user_preferences (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    preference_type TEXT NOT NULL CHECK (preference_type IN ('like', 'dislike', 'favorite', 'avoid')),
    category TEXT NOT NULL CHECK (category IN ('ingredient', 'cuisine', 'cooking_method', 'flavor')),
    value TEXT NOT NULL,
    strength INTEGER DEFAULT 5 CHECK (strength >= 1 AND strength <= 10),
    source TEXT NOT NULL DEFAULT 'explicit' CHECK (source IN ('explicit', 'inferred')),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(user_id, preference_type, category, value)
);

-- ============ AI Generated Recipes ============
-- Recipes generated by AI from user's ingredients
CREATE TABLE IF NOT EXISTS ai_generated_recipes (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    input_ingredients TEXT[] NOT NULL,
    generated_recipe JSONB NOT NULL,
    was_cooked BOOLEAN DEFAULT false,
    feedback_id UUID REFERENCES cooking_feedback(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- ============ Recipe Favorites ============
-- User's favorite recipes
CREATE TABLE IF NOT EXISTS recipe_favorites (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    recipe_id TEXT NOT NULL,
    added_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(user_id, recipe_id)
);

-- ============ Weekly Plans ============
-- Weekly meal planning
CREATE TABLE IF NOT EXISTS weekly_plans (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    date DATE NOT NULL,
    recipe_id TEXT NOT NULL,
    meal_type TEXT NOT NULL CHECK (meal_type IN ('breakfast', 'lunch', 'dinner')),
    status TEXT DEFAULT 'planned' CHECK (status IN ('planned', 'cooked', 'skipped')),
    scale_factor DECIMAL(3,2) DEFAULT 1.0,
    is_for_bento BOOLEAN DEFAULT false,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(user_id, date, meal_type)
);

-- ============ Shopping List ============
-- Generated shopping list from weekly plans
CREATE TABLE IF NOT EXISTS shopping_list (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    item_name TEXT NOT NULL,
    quantity TEXT,
    category TEXT DEFAULT 'other',
    is_checked BOOLEAN DEFAULT false,
    is_manual_add BOOLEAN DEFAULT false,
    source_plans UUID[] DEFAULT '{}',
    week_start DATE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- ============ Pantry (Inventory) ============
-- User's current pantry items
CREATE TABLE IF NOT EXISTS pantry (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    category TEXT DEFAULT 'other',
    quantity TEXT,
    expiry_date DATE,
    added_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- ============ Cooking History ============
-- Complete cooking history with photos
CREATE TABLE IF NOT EXISTS cooking_history (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    recipe_id TEXT NOT NULL,
    recipe_name TEXT NOT NULL,
    recipe_emoji TEXT,
    photo_url TEXT,
    rating INTEGER CHECK (rating >= 1 AND rating <= 5),
    memo TEXT,
    cooked_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    feedback_id UUID REFERENCES cooking_feedback(id)
);

-- ============ Indexes ============
CREATE INDEX IF NOT EXISTS idx_user_profiles_user_id ON user_profiles(user_id);
CREATE INDEX IF NOT EXISTS idx_cooking_feedback_user_id ON cooking_feedback(user_id);
CREATE INDEX IF NOT EXISTS idx_cooking_feedback_recipe_id ON cooking_feedback(recipe_id);
CREATE INDEX IF NOT EXISTS idx_user_preferences_user_id ON user_preferences(user_id);
CREATE INDEX IF NOT EXISTS idx_ai_generated_recipes_user_id ON ai_generated_recipes(user_id);
CREATE INDEX IF NOT EXISTS idx_weekly_plans_user_id_date ON weekly_plans(user_id, date);
CREATE INDEX IF NOT EXISTS idx_shopping_list_user_id ON shopping_list(user_id);
CREATE INDEX IF NOT EXISTS idx_pantry_user_id ON pantry(user_id);
CREATE INDEX IF NOT EXISTS idx_cooking_history_user_id ON cooking_history(user_id);

-- ============ Row Level Security ============
ALTER TABLE user_profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE cooking_feedback ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_preferences ENABLE ROW LEVEL SECURITY;
ALTER TABLE ai_generated_recipes ENABLE ROW LEVEL SECURITY;
ALTER TABLE recipe_favorites ENABLE ROW LEVEL SECURITY;
ALTER TABLE weekly_plans ENABLE ROW LEVEL SECURITY;
ALTER TABLE shopping_list ENABLE ROW LEVEL SECURITY;
ALTER TABLE pantry ENABLE ROW LEVEL SECURITY;
ALTER TABLE cooking_history ENABLE ROW LEVEL SECURITY;

-- ============ RLS Policies ============
-- Users can only see/modify their own data

-- user_profiles
CREATE POLICY "Users can view own profile" ON user_profiles FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Users can insert own profile" ON user_profiles FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can update own profile" ON user_profiles FOR UPDATE USING (auth.uid() = user_id);

-- cooking_feedback
CREATE POLICY "Users can view own feedback" ON cooking_feedback FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Users can insert own feedback" ON cooking_feedback FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can update own feedback" ON cooking_feedback FOR UPDATE USING (auth.uid() = user_id);

-- user_preferences
CREATE POLICY "Users can view own preferences" ON user_preferences FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Users can insert own preferences" ON user_preferences FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can delete own preferences" ON user_preferences FOR DELETE USING (auth.uid() = user_id);

-- ai_generated_recipes
CREATE POLICY "Users can view own AI recipes" ON ai_generated_recipes FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Users can insert own AI recipes" ON ai_generated_recipes FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can update own AI recipes" ON ai_generated_recipes FOR UPDATE USING (auth.uid() = user_id);

-- recipe_favorites
CREATE POLICY "Users can view own favorites" ON recipe_favorites FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Users can insert own favorites" ON recipe_favorites FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can delete own favorites" ON recipe_favorites FOR DELETE USING (auth.uid() = user_id);

-- weekly_plans
CREATE POLICY "Users can view own plans" ON weekly_plans FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Users can insert own plans" ON weekly_plans FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can update own plans" ON weekly_plans FOR UPDATE USING (auth.uid() = user_id);
CREATE POLICY "Users can delete own plans" ON weekly_plans FOR DELETE USING (auth.uid() = user_id);

-- shopping_list
CREATE POLICY "Users can view own shopping list" ON shopping_list FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Users can insert own shopping items" ON shopping_list FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can update own shopping items" ON shopping_list FOR UPDATE USING (auth.uid() = user_id);
CREATE POLICY "Users can delete own shopping items" ON shopping_list FOR DELETE USING (auth.uid() = user_id);

-- pantry
CREATE POLICY "Users can view own pantry" ON pantry FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Users can insert own pantry items" ON pantry FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can update own pantry items" ON pantry FOR UPDATE USING (auth.uid() = user_id);
CREATE POLICY "Users can delete own pantry items" ON pantry FOR DELETE USING (auth.uid() = user_id);

-- cooking_history
CREATE POLICY "Users can view own cooking history" ON cooking_history FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Users can insert own cooking history" ON cooking_history FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can update own cooking history" ON cooking_history FOR UPDATE USING (auth.uid() = user_id);

-- ============ Functions ============

-- Function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ language 'plpgsql';

-- Trigger for user_profiles
CREATE TRIGGER update_user_profiles_updated_at
    BEFORE UPDATE ON user_profiles
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- Function to get user's preference summary
CREATE OR REPLACE FUNCTION get_user_preference_summary(p_user_id UUID)
RETURNS JSONB AS $$
DECLARE
    result JSONB;
BEGIN
    SELECT jsonb_build_object(
        'likes', (
            SELECT jsonb_agg(value)
            FROM user_preferences
            WHERE user_id = p_user_id AND preference_type = 'like'
        ),
        'dislikes', (
            SELECT jsonb_agg(value)
            FROM user_preferences
            WHERE user_id = p_user_id AND preference_type = 'dislike'
        ),
        'favorites', (
            SELECT jsonb_agg(value)
            FROM user_preferences
            WHERE user_id = p_user_id AND preference_type = 'favorite'
        ),
        'cooking_count', (
            SELECT COUNT(*)
            FROM cooking_feedback
            WHERE user_id = p_user_id
        ),
        'avg_rating', (
            SELECT AVG(rating)::DECIMAL(3,2)
            FROM cooking_feedback
            WHERE user_id = p_user_id
        )
    ) INTO result;

    RETURN result;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
